
컬렉션 프레임워크 : 자료구조와 알고리즘을 구현해 놓은 인터페이스

Collection 인터페이스 에  list 인터페이스 와 set 인터페이스 가  있다 그외에 map 이 있다.

자료구조는 연속된(선형) 자료구조 이다.
논리적인 구조와 물리적인 구조가 동일하다  

논리적인것 선형, 물리적인은 동떨어져있는걸 LinkedList 라고 한다.

Array - 연속된 데이터가 중간에 빠지면 앞으로 땅긴다 - 자료구조의 옵셋만큼만 하면 찾음 , 자료변동이 적으면 Array
Linked - 중간에 빠지면 링크만 조절 , i번째 찾으려면 처음부터 찾아가야함 , 동적 메모리 허용 연결해서 사용 가능 , 자료의 변동이 심하면  Linked 

ArrayList , 그이후 Vector  지금 ArrayList을 많이 쓰고 
LinkedList 

선형 자료구조 중에  Stack , Queue 가 있다.
Stack - LIFO - ArrayList - 맨위 Top , 데이터 집어넣는 push() , 꺼내는 pop()
Queue - FIFO - 선착순 - ArrayList , 맨앞 Front , 뒤 rear , 들어가는 오퍼레이션 enqueue() , 나오는 오퍼레이션 dequeue()

Hash 검색을 위한 자료 구조 
hash(K,V)  
index = hash(Key)    key를 주면 인덱스의 위치를 알려준다. hash 산술연산을 줘서 굉장히 빠르다. 검색에 대한 속도가 빠르다 
key는 중복되지 않는다. 

극장에 좌석이 0~99 표300장 1번부터 300번까지 표를 파는데 15번이 영화를 보러왔는데 어디에 앉히면 좋을까
자리가 100개면  15를  100으로 나누면 나머지 15가 나오면 15번 자리에 앉힌다. 115번이 오면 100으로 나누고  나머지 15가 나오면  이미 앉힌사람과의 충돌이 발생한다
hash테이블은 이럴때 쓴다. 그 위치에 가서 찾으면 된다. hash 테이블은 꽉차게 쓰지않는다  
hashset 과 hashmap   hash키워드는 검색을 위한 알고리즘 데이터를 빨리 찾아준다. 

binary tree 

부모보다 자식이 작으면 
binary search tree 
검색을 위한 트리  , 데이터가 중복되서 들어갈수없다. 데이터를 넣을때 비교를 해서 비교조건에 의해서 작은건 왼쪽으로 큰건 오른쪽으로 
나를 중심으로 해서 나에 왼쪽은 나보다 작은값 오른쪽은 나보다 큰값 


List 인터페이스
객체를 순서에 따라 저장하고 관리하는데 필요한 
ArrayList 와 Vector 가 있다.
Vector 는 멀티 쓰레드 프로그램에서 동기화를 지원한다. 동기화(synchronization) 두개의 쓰레드가 동시에 하나의 리소스에 접근할때 순서를 맞추어서 데이터의 오류가 방지하지 않도록함

capacity - 용량을 의미 
size - 그 안에 실제 들어간 개수

ArrayList 와 LinkedList 둘다 자료의 순차적 구조를 구현
LinkedList에서 자료의 추가와 삭제 가 빠르다 

Stack - 최근 자료 가져오기 상자라고 생각
Queue - 선착순 , 대기열 , 맨앞에서 빼고 맨 뒤에서 추가된다. 맨앞 front 뒤 rear 이다.


Iterator 로 순회하기
Collection 의 객체를 순회하는 인터페이스

set은 순서대로 저장 x  몇번째꺼 꺼내는 방식 iterator 이용해서  사용할수있다.

Iterator it = memberArrayList.iterator();


                             ArrayList 단점 
// 0번쨰 방에 111 을 넣으면 그값에 있던 값들은 뒤로 밀린다.
// 앞에 비워두면 한칸씩 앞으로 다 땡긴다.
// 중간에 데이터를 삭제하거나 삽입하는걸 굉장히 불안하게 생각한다. 
// 데이터를 뒤에 추가하고 뒤에서부터 삭제하는게 좋은방법이다.
  ArrayList 단점을 보완하기 위해 LinkedList 나옴
  헤더의 노드 에는 다음값의 주소를 갖고  있다
  가운대 데이터 주소를 지우는 순간 다음 데이터를 채운다.
장점 : 중간에 삽입삭제 하는데 좋다
 
 단점 : 한번갔더니 뒤로 못온다. 그래서 나온구조가  이중원형링크드리스트
 헤더를 2개 가져서 하나는 다음번지주소 다른하나는 이전번지 주소 
 
 한번에 못가고 계속 하나씩 참조하면서 가야된다는 단점떄문에  또하나 나옴  더블리 링크드 리스트가 나옴
 마지막 노드 헤더값을  첫번쨰 노드헤더값을 가져서 한번에 갈수있다.  
 이걸 가지고 만들어 오라고 하면 철길시스템 
 
 class Node {
 	Node next;
 	Object obj;
 }
 
컬렉션 프레임 웍 의 핵심 인터페이스
Stack 클래스 만들어본다


스텍 - LIFO  마지막에 넣은걸 가장 먼저 빼낸다

데이터 넣을떄 PUSH
데이터 뺴낼떄 POP

안드로이드 엑티비티도 스택 구조 

큐 - 가장 먼저 들어간게 가장 먼저 빠져나온다   ex ) 수강신청 , 버스에서 줄스기 , 버퍼


















 

