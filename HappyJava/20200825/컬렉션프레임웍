컬렉션 프레임 웍

데이터들을 모아서 저장하는 클래스들을 표준화한 설계
다수의 데이터를 쉽게 처리할수있는 방법을 제공하는 클래스들로 구성

컬렉션 : 다수의 데이터
프레임웍 : 표준화(기준화)한 설계 (표준화=기준)
컬렉션 프레임워크 : 수많은 인터페이스와 클래스들을 미리 만들어놓음

Collection 인터페이스  - 대다수의 약속을 만들어놓음  

확장해놓은게  List 와 Set
List - 줄을서세요 . 순서가 있는 데이터의집합 , 데이터의 중복을 허용한다. - 번호표로 중복을 알아낸다  ex) 대기자명단 Vector,ArrayList,LinkedList,Stack  
Set - 원안에 들어가세요.순서가없다,중복을 허용하지 않는다.ex) 양의집합  HashSet , TreeSet 
Map - 우편번호 - key 02 value 서울  
ArrayList , LinkedList는  List를 구현  순서가있는 데이터의 집합  그래서  쓰는 함수가 똑같다  
 동기화(synchronization)-스택이 여러개 이다. 
 동기화의 전제 조건 - 실행하는 애들이 여러개  Thread 
 
(일처리-성능)
 사람들이 화장실에 들어가려고함
Vector  화장실 공유자원 - 한명이 들어가서 문을잠금 (공유자원 보호)-공유자원은 누군가 점유했을때 보호-기다리는사람들은 대기상태에 빠짐 -동기화는 프라이버시 ,성능이 좋지 않다 
Array 한강에 사람들이 비빔밥을 먹는데  다같이 먹음 - 성능이 좋다 
(비빔밥)동기화를 보장하지않으면 성능이 좋다 (화장실)동기화를 보장하면 성능이 좋지 않다.

Vector 의 크기(Size)와 용량(capacity)
Vector v = new Vector(5); 5개의 공간이 생김
v.add("1");               0번방에 1 
v.add("2");
v.add("3");            나머지는 null
capacity : 5개의 정적배열 , 추가할때마다 자신의 가지고있는것에 2배로 만든다 (추가할떄마다 계속해서 array를 만든다.) 지가 필요하면 재할당을 해준다. 
늘렸다줄었다 하는것이 아닌 새로운 배열을 만들어서 이사를 간다 새로운 매모리 할당 
clear : 요소 제거 - 빈공간을 null로 만듬 

v
                             ArrayList 단점 
// 0번쨰 방에 111 을 넣으면 그값에 있던 값들은 뒤로 밀린다.
// 앞에 비워두면 한칸씩 앞으로 다 땡긴다.
// 중간에 데이터를 삭제하거나 삽입하는걸 굉장히 불안하게 생각한다. 
// 데이터를 뒤에 추가하고 뒤에서부터 삭제하는게 좋은방법이다.
  ArrayList 단점을 보완하기 위해 LinkedList 나옴
  헤더의 노드 에는 다음값의 주소를 갖고  있다
  가운대 데이터 주소를 지우는 순간 다음 데이터를 채운다.
장점 : 중간에 삽입삭제 하는데 좋다
 
 단점 : 한번갔더니 뒤로 못온다. 그래서 나온구조가  이중원형링크드리스트
 헤더를 2개 가져서 하나는 다음번지주소 다른하나는 이전번지 주소 
 
 한번에 못가고 계속 하나씩 참조하면서 가야된다는 단점떄문에  또하나 나옴  더블리 링크드 리스트가 나옴
 마지막 노드 헤더값을  첫번쨰 노드헤더값을 가져서 한번에 갈수있다.  
 이걸 가지고 만들어 오라고 하면 철길시스템 
 
 class Node {
 	Node next;
 	Object obj;
}
컬렉션 프레임 웍 의 핵심 인터페이스
Stack 클래스 만들어본다




